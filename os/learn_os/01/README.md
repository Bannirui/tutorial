32位引导过程
---

CPU的工作模式，不同的工作模式，内存寻址在演进

- 16位实模式

- 32位保护模式

- 64位长模式

因为历史包袱，CPU加电后工作在实模式下，需要程序一步一步切换模式，不同模式之间的切换不能越级进行，最终工作在64位模式下

### 1 16位实模式

之所以叫实模式，因为处理器使用真实的物理地址访问内存

处理器的入口是2个16位寄存器

- 段寄存器

- 指针寄存器

算法是`段基址<<4+偏移地址`，处理器的地址加法器(也叫处理器的段单元)负责这个计算，计算结果就是20位的物理内存地址

这种模式有啥问题

- 寻址空间太小，地址才20位，寻址空间才1M

- 不安全，实模式的一个主要问题是程序之间的内存没有隔离，任何一个程序都可以随意更改段寄存器，进而访问任意地址的内存。换句话说，==实模式允许一个程序可以随意访问或者破坏掉另一个程序的数据或者代码，这是不安全的==

### 2 32位保护模式

因为实模式的问题，Intel引入了新的模式-保护模式

在保护模式下，CPU具有4个特权级

- 特权级0(ring0)

- 特权级1(ring1)

- 特权级2(ring2)

- 特权级3(ring3)

只有运行在特权级0的指令才有权操作关键资源

- 操作系统内存一般运行在特权级0

- 应用程序一般运行在特权级3

保护模式下寻址空间4G

x86设计了段描述符表来记录段的信息，它的本质是一个数组，数组中每个元素是一个段描述符。只有运行在特权级0的指令才有权操作这个表

也就意味着只有操作系统的内核才有权操作段描述符表，内核会为每个程序分配彼此隔离的物理内存

每当程序访问内存时，内存管理单元将依据段描述符中的信息对其进行合法性检查，一旦发现有程序进行非法访问，则抛出异常

保护模式下，段寄存中装载的不再是段基址，而是段描述符的数组的索引

每当访问一个内存地址时，内存管理单元首先从段寄存器中取出段的索引，根据索引从段描述符表中读取对应的段描述符，然后从段描述符中取出段基址，再加上段内偏移就生成了物理地址

### 3 平坦模型

- 8086处理器数据总线和地址总线宽度20

- 80386处理器数据总线和地址总线宽度32

16位的8086为支持20位的地址设计的段机制已经不需要了，但是为了兼容之前写的程序，x86建议系统设计者使用一种最大限度隐藏段机制的平坦模型

- 将段的基址设置为0

- 段长设置为线性地址空间的整个长度

### 4 实模式地址空间

|地址|内容|
|---|---|
|0x000000|中断向量表|
|0x0003ff|BIOS数据区|
|0x0004ff||
|0x007c00|操作系统加载器|
|0x007dff||
|0x080000|扩展BIOS数据区|
||显存|
||显卡BIOS|
||BIOS扩展|
||主板BIOS|
|0x0100000||

### 5 内核映像布局

kvmtool启动后

- 将各段寄存器初始化为0x1000

- 指令指针初始化为0

因此虚拟机启动后执行的第一条指令地址为`CS<<4+IP`为0x10000

所以内核的实模式部分必须部署在0x10000处

- 实模式部分部署在0x10000处

- 保护模式部分的起始地址没有严格要求，从实模式跳转到保护模式部分的内核由自己控制，部署在0x20000处

- 64位模式部分部署在0x100000处

|地址|内容|
|---|---|
|0x000000|中断向量表|
|0x0003ff|BIOS数据区|
|0x0004ff||
|0x007c00|操作系统加载器|
|0x007dff||
|0x010000|实模式部分|
|0x020000|保护模式部分|
|0x080000|扩展BIOS数据区|
||显存|
||显卡BIOS|
||BIOS扩展|
||主板BIOS|
|0x0100000|64位模式部分|

又因为kvmtool的处理器初始取址是0x10000

|程序|部署的内存地址|在整个可执行程序文件中的偏移|
|---|---|---|
|实模式部分|0x10000|0x10000-0x10000|
|保护模式部分|0x20000|0x20000-0x10000|
|64位模式部分|0x100000|0x100000-0x10000|

那么链接中间文件到可执行文件的时候需要指定代码偏移地址

- 实模式部分 指定偏移0 让kvmtool读到首条指令

- 保护模式部分 指定偏移0x20000

- 64位模式部分 指定偏移0x100000

### 6 段描述符

#### 6.1 段描述符格式

每个段描述符长度为64位，包括段基址、段长度，以及段的访问权限等各种属性

- 高32位

  - [31...24] 段基址(24~31)

  - [23] 粒度

    - 0 段的长度以字节为单位

    - 1 段的长度以4KB位单位

  - [22] D/B

    - 对于代码段

      - 0表示16位

      - 1表示32位

    - 对于栈段

      - 0表示使用寄存器SP作为栈指针

      - 1表示使用寄存器ESP作为栈指针

    - 对于向下扩展的数据段

      - 0表示段的上限为64KB

      - 1表示段的上限为4GB

  - [21] 长模式 这个字段仅适用于64位模式下的代码段 
  - 0表示在64位模式下运行在兼容模式下，可以运行16位和32位程序
    
  - 1表示运行在64位模式下
    
- [20] 系统软件使用 这个字段留给特殊的系统软件使用的
  
- [19...16] 段长度(16~19)
  
- [15] 存在位 用于标识段是否存在于内存中
    - 0表示段被换出内存
  
    - 1表示段在内存中
  
  - [14...13] 特权级

  - [12] 描述符类型

    - 0表示系统段

    - 1表示代码段/数据段

  - [11...8] 段类型 系统段和代码段/数据段的值各不相同 第11位表示段为代码段还是数据段 0表示数据段 1表示代码段

    - 数据段

      - [11] 0

      - [10] 扩展方向 表示数据段的扩展方向

        - 0表示从低地址到高地址方向扩展

        - 1表示从高地址到低地址方向扩展

      - [9] 是否可写 数据段是否可写

        - 0表示不可写

        - 1表示可写

      - [8] 是否访问过 由处理器自动设置

    - 代码段

      - [11] 1

      - [10] 是不是一致性代码段 所谓一致性就是段是否允许运行于不同特权级的处理器访问

      - [9] 是否可读

        - 0表示不可读

        - 1表示可读

      - [8] 是否访问过 由处理器自动设置，初始值0，如果一旦段被访问，处理器就会将此设置为1

  - [7...0] 段基址(16~23)

- 低32位

  - [31...16] 段基址(0~15)

  - [15...0] 段长度(0~15)

#### 6.2 段描述符字段含义

- 段基址

- 段长度 段的限长，单位根据粒度决定

### 7 保护模式的代码段描述符

使用平坦模型

典型的平坦模型包含4个段

- 特权级3的用户代码段

- 特权级3的用户数据段

- 特权级0的内核代码段

- 特权级0的内核数据段

因为保护模式仅仅是过渡，不回进入用户空间，因此只需要准备内核代码段和内核数据段的段描述符

平坦模式，意味着段基址是0

#### 7.1 内核代码段

- 平坦模式段基址为0

- 32位保护模式部分代码部署在0x20000处的，它要访问的最大地址就是跳转到部署在0x100000处的64位模式程序，准备一个8MB的内核代码段足够使用了

- 8MB，粒度为4KB，8MB/4Kb=2048，基0~2047，段长度为2047

|31|30|29|28|27|26|25|24|23|22|21|20|19|18|17|16|15|14|13|12|11|10|9|8|7|6|5|4|3|2|1|0|31|30|29|28|27|26|25|24|23|22|21|20|19|18|17|16|15|14|13|12|11|10|9|8|7|6|5|4|3|2|1|0|
|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|
|0|0|0|0|0|0|0|0|1|1|0|0|0|0|0|0|1|0|0|1|1|0|1|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|1|1|1|1|1|1|1|1|1|1|1|

对应的16进制是0x00c0 9a00 0000 07ff

#### 7.2 内核数据段

- 数据段从低地址向高地址增长

| 31   | 30   | 29   | 28   | 27   | 26   | 25   | 24   | 23   | 22   | 21   | 20   | 19   | 18   | 17   | 16   | 15   | 14   | 13   | 12   | 11   | 10   | 9    | 8    | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    | 31   | 30   | 29   | 28   | 27   | 26   | 25   | 24   | 23   | 22   | 21   | 20   | 19   | 18   | 17   | 16   | 15   | 14   | 13   | 12   | 11   | 10   | 9    | 8    | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 1    | 1    | 0    | 0    | 0    | 0    | 0    | 0    | 1    | 0    | 0    | 1    | 0    | 0    | 1    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    |

对应的16进制是0x00c0 9200 000 07ff

### 8 创建保护模式的段描述符表

x86处理器约定

- 段描述符表的第0项保留不用，将第0项设置为0

- 将第1项定义内核代码段

- 将第2项定义内核数据段

由于内核在初始化过程中还没做好处理外部中断的准备，因此在开启初始化过程中先用cli指令清除掉标志寄存器中的中断位，告知处理器不要响应外部中断

实模式和保护模式仅仅是过渡模式，所以在这两个模式下不处理中断，直到64位模式准备好响应中断

### 9 告知处理器段描述符表地址

x86处理器使用一个寄存器GDTR来记录段描述符表的地址

保护模式下寄存器GDTR的长度为48位

- [47...16] 段描述符表地址

- [15...0] 段描述符表长度 数组占空间多少个byte

x86处理器提供了专用的指令lgdt从内存中加载段描述符表地址到寄存器GDTR

### 10 开启保护模式

处理器的控制寄存器CR0的第0位PE用于控制处理器是否开启保护模式

CR0是32位的

### 11 跳转到保护模式部分

处理器不允许程序直接修改指令指针寄存器，所以需要通过跳转指令完成模式切换

要跳转到保护模式，需要完成2件事情

- 更新代码段寄存器CS

  - 处于实模式时，CS中存储的是一个段基址

  - 切换到保护模式后，CS需要存储的是内核代码段在段描述符表中的索引

- 指令指针指向保护模式入口处的指令

段寄存器中存储的段描述符表的索引有自己的格式要求

保护模式下的段寄存器分为可见部分和不可见部分

- 可见部分称为段选择子

- 不可见部分仅供处理器内部使用

段寄存器的可见部分段选择子是程序软件可以操作的，这16位布局如下

- [15...3] 段索引 表示段在段描述符表中的索引

- [2] TI 标识是全局段描述符表中的段还是局部段描述符表中的段

  - 0表示全局描述符表中的段

  - 1表示段在程序的段描述符表中

- [1...0] 特权级