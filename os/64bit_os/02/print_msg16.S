# 打印字符串
# call调用这个函数之前用栈传递参数
#   第1个参数是字符串长度
#   第2个参数是字符串地址
#   第3个参数16位整数 高8位表示显示的行号 低8位表示显示的列号
# 
# 主调函数把要打印的字符串地址压栈方式传过来了 16位处理器下默认压栈参数1word=16bit=2byte
#
# 栈的内存布局如下
# 以当前函数栈帧的栈帧基址为锚点
# BP+6 第1个参数 字符串长度
# BP+4 第2个参数 字符串地址
# BP+2 返回地址 被调函数执行完ret回去的地址
# BP   栈帧基址 放的主调函数的栈帧基址
# BP-2 当前函数维护的局部变量

.text
.code16

.global print_msg

# 调用中断屏幕显示字符串
# 中断号int 0x10
# 功能号AH 0x13
# AL 写入模式
#          Al=0x00 字符串属性由BL寄存器控制 字符串长度由CX寄存器控制(以Byte为单位) 光标位置不变(即写入前光标在哪写入后还在哪)
#          Al=0x01 字符串属性由BL寄存器控制 字符串长度由CX寄存器控制(以Byte为单位) 写入后光标在字符串尾端位置
#          Al=0x02 字符串属性由每个字符后面紧跟的字节提供 字符串长度由CX寄存器控制(以Word为单位) 光标位置不变(即写入前光标在哪写入后还在哪)
#          Al=0x03 字符串属性由每个字符后面紧跟的字节提供 字符串长度由CX寄存器控制(以Word为单位) 写入后光标在字符串尾端位置
# CX 字符串长度
# DH 游标行号 0-based 显示字符串的光标起始行
# DL 游标列号 0-based 显示字符串的光标起始列
# ES:BP 要显示的字符串内存地址
# BH 页码
# BL 字符串属性
#          BL[7]     字体闪烁 0=不闪烁 1=闪烁
#          BL[4...6] 背景颜色 0=黑色 1=蓝色 2=绿色 3=青色 4=红色 5=紫色 6=棕色 7=白色
#          BL[3]     字体亮度 0=字体正常 1=字体高亮
#          BL[0...2] 字体颜色 0=黑色 1=蓝色 2=绿色 3=青色 4=红色 5=紫色 6=棕色 7=白色
print_msg:
    # 栈帧基址
    push %bp
    mov %sp, %bp

    # AH功能号0x13 AL写入模式0x01(BL控制显示属性 CX控制字符串长度 打印字符串之后光标停留在字符串尾端位置)
    mov $0x1301, %ax
    # BH页码0页 BL字体属性00000100(不闪烁 背景黑色 字体高亮 字体红色)
    mov $0x0004, %bx
    # 栈传递的第1个参数 字符串长度
    mov 8(%bp), %cx
    # 栈传递的第3个参数 字符串从屏幕什么位置开始显示
    mov 4(%bp), %dx
    # 要用ES:BP寻址 把DS给ES 段寄存器不能直接赋值 用AX中转
    push %ax
    mov %ds, %ax
    mov %ax, %es
    pop %ax
    # 栈传递的第2个参数 要打印的字符串地址
    mov 6(%bp), %bp
    int $0x10

    # 恢复BP 指向主调函数的栈帧基址 销毁当前函数栈帧 回到返回地址
    mov %bp, %sp
    pop %bp
    ret