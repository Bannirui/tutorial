.text
.code16
# 伪指令告诉汇编器设置sum函数为全局符号 将来在ld链接的时候才能找到这个符号 跨文件调用
.global sum

sum:
    # 此时栈帧里面已经放了call指令放进去的函数返回地址
    # 又手动push了主调函数的栈帧基址
    push %bp
    # 此时栈顶sp指向的就是被调函数的栈帧基址了 维护到BP寄存器中
    mov %sp, %bp
    # 上面两行代码会被简化为enter指令

    # x86调用约定规定了在压栈主调函数的栈帧基址后 在栈上为局部变量开辟空间
    # 以BP为锚点 [BP-2...BP]这2个byte空间
    # 开辟2byte的空间给局部变量 栈顶下移2个byte 将来这个位置存储局部变量
    sub $2, %sp

    mov $1, %bx
    mov $0, %ax

1:
    # 以BP为锚点 定位到局部变量的地址
    add %bx, -2(%bp)
    inc %bx
    # 以当前函数栈帧基址为锚点 从低地址往高地址看
    # BP 存放主调函数的栈帧基址 占2个byte
    # BP+2 存放函数返回地址 占2个byte
    # BP+4 存放函数第1个参数 占2个byte
    # BP+6 存放函数第2个参数 占2个byte
    # ...
    cmp 4(%bp), %bx
    jbe 1b

    # 求和的值放在了局部变量上
    # 被调函数在销毁栈帧之前将函数结果通过寄存器AX传递给主调函数
    mov -2(%bp), %ax

    # 通过移动栈顶指针的方式销毁当前函数的栈帧
    # 不管现在栈顶SP指向哪儿 直接拉到当前函数的栈帧基址地方
    mov %bp, %sp
    # 此时当前函数栈帧还存储着两个信息 从低到高依次是 主调函数的栈帧基址 主调函数的返回地址
    # 被调函数要执行ret结束了 恢复BP 指向主调函数的栈帧基址
    pop %bp
    # 上面这两行代码会被简化为leave指令
    ret
