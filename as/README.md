汇编
---

以AT&T语法为例，我个人比较喜欢这个风格

### 1 基础

汇编语言程序由若干汇编指令组成，一条x86汇编指令基本格式如下

`标签:助记符 操作数1, 操作数2, 操作数3`

其中

- 标签 这一部分可选，用于标识指令的地址。通常用于控制指令流，比如jmp指令后面可以跟一个标签，表示跳转到标签标识的指令处

- 助记符 这部分是指令操作码的符号表示，用于帮助记忆指令，是指令中必不可少的部分

- 操作数 x86的汇编指令支持0到3个操作数，具体数量依赖于具体的指令。操作数之间用逗号分隔，操作数通常分别称为源操作数和目的操作数

### 2 格式

AT&T代码语法风格

- 源操作数在左，目的操作数在右

- 寄存器前面需要使用符号%

汇编程序每条语句占据一行，大小写不敏感，一般使用小写字母形式

### 3 指令

#### 3.1 伪指令

在汇编程序中，所有伪指令都是以.开头的。所谓伪指令，并不会被翻译为处理器执行的机器指令，只是程序员给汇编器的一些指示。

- .text告知汇编器接下来这是代码段

- .code16告知汇编器生成16位的汇编代码

#### 3.2 out指令

有2个操作数

- 源操作数为累加寄存器，根据源操作数位数分别使用AL、AX或者EAX，存储向串口发送的内容

- 目的操作数表示外设端口地址

  - 当端口地址小于256时，目的操作数可以直接使用8位立即数

  - 否则目的操作数用寄存器，比如DX，存储外设端口地址

#### 3.3 mov

将字符装载到寄存器中

#### 3.4 hlt

告诉处理器停止运行

### 4 汇编和链接

编写完汇编程序后，需要将其翻译为机器指令，将汇编程序翻译为机器指令过程包含2步

- 汇编 汇编会将汇编程序翻译为处理器认识的机器码，汇编器翻译后的输出称为目标代码(object code)，包含目标代码的文件称为目标文件

- 链接 目标代码需要经过链接过程生成处理器可以运行的代码，对应的文件称为可执行文件

linux中负责汇编的工具为as，负责链接的工具为ld

- as 汇编 `as hello.s -o hello.o`

- ld 链接 `ld -Ttext=0 hello.o -o hello.elf`

事实上，经过汇编和链接后，生成的目标文件是ELF格式的，其除了存储代码和数据部分外，还记录了其他信息，比如段的信息、符号表和调试信息等

- objdump 反汇编将机器码还原为汇编指令 `objdump -d -m i8086 hello.elf`

  - 选项-d是disassemble首字母，告诉objdump进行反汇编

  - 选项-m i8086表示体系结构是16位的8086

- hexdump 将文件内容原封不动显示出来 `hexdump -C hello.elf`

- objcopy 操作目标文件，将ELF文件中的代码和数据部分复制出来，这个没有任何格式的文件称为binary文件 `objcopy -O binary hello.elf hello.bin`

### 5 示例

- [屏幕输出字符A](./01)